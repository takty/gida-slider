"use strict";

/**
 *
 * Gida Slider - Hero (JS)
 *
 * @author Takuto Yanagida
 * @version 2021-07-05
 *
 */
window.GIDA = window['GIDA'] ?? {};

window.GIDA.slider_hero = function (id, opts) {
  const NS = 'gida-slider-hero';
  const CLS_SLIDES = NS + '-slides';
  const CLS_VISIBLE = 'visible';
  const CLS_DISPLAY = 'display';
  const CLS_VIEW = 'view';
  const CLS_PAUSE = 'pause';
  const OFFSET_VIEW = 100;
  const root = id ? document.getElementById(id) : document.getElementsByClassName(NS)[0];
  if (!root) return;
  if (opts === undefined) opts = {};
  const effectType = opts['effect_type'] ?? 'slide';
  const timeDur = opts['duration_time'] ?? 8; // [second]

  const timeTran = opts['transition_time'] ?? 1; // [second]

  const randomTiming = opts['is_random_timing'] ?? false;
  const slides = Array.prototype.slice.call(root.querySelectorAll(`.${CLS_SLIDES} > li`));
  const size = slides.length;
  const pics = [];
  let effect = null;
  let onTransitionEnd = null;
  let hasVideo = false; // -------------------------------------------------------------------------

  /**
   *
   * Common Functions (JS)
   *
   * @author Takuto Yanagida
   * @version 2021-06-30
   *
   */

  const resizeListeners = [];

  function onResize(fn, doFirst = false) {
    if (doFirst) fn();
    resizeListeners.push(throttle(fn));
  } // -----------------------------------------------------------------------------


  document.addEventListener('DOMContentLoaded', () => {
    window.addEventListener('resize', () => {
      for (const l of resizeListeners) l();
    }, {
      passive: true
    });
  });

  function throttle(fn) {
    let isRunning;

    function run() {
      isRunning = false;
      fn();
    }

    return () => {
      if (isRunning) return;
      isRunning = true;
      requestAnimationFrame(run);
    };
  }

  function asyncTimeout(ms, fn = () => {}) {
    let tid = null;
    let res;
    return {
      set: () => new Promise(r => {
        res = r;
        tid = setTimeout(async () => {
          tid = null;
          await fn();
          r();
        }, ms);
      }),
      clear: () => {
        if (tid) {
          clearTimeout(tid);
          tid = null;
          res();
        }
      }
    };
  }
  /**
   *
   * Slide Transition
   *
   * @author Takuto Yanagida
   * @version 2021-06-25
   *
   */


  class TransitionSlide {
    constructor(size, slides, tranTime) {
      this._size = size;
      this._sls = slides;
      this._time = tranTime;

      for (let i = 0; i < this._size; i += 1) {
        this._sls[i].style.transform = 'translateX(' + (i ? 100 : 0) + '%)';
      }

      setTimeout(() => {
        for (let i = 0; i < this._size; i += 1) {
          this._sls[i].style.opacity = 1;
          this._sls[i].style.transition = 'transform ' + this._time + 's';
        }
      }, 10);
    }

    async transition(idx, dir) {
      for (let i = 0; i < this._size; i += 1) {
        this._sls[i].style.transform = i <= idx ? 'translateX(0%)' : 'translateX(100%)';
      }

      await asyncTimeout(this._time * 1000).set();
    }

  }
  /**
   *
   * Scroll Transition
   *
   * @author Takuto Yanagida
   * @version 2021-06-29
   *
   */


  class TransitionScroll {
    constructor(size, slides, tranTime) {
      this._size = size;
      this._sls = slides;
      this._time = tranTime;
      this._curIdx = 0;
      this._curIdxPsd = 0;
      this._curPos = this._calcPosition(0, 1);

      for (let i = 0; i < this._sls.length; i += 1) {
        this._sls[i].style.opacity = 1;
        this._sls[i].style.transform = `translateX(${this._curPos[i] * 100}%)`;
      }
    }

    async transition(idx, dir) {
      this._curPos = this._calcPosition(this._curIdxPsd, dir);

      for (let i = 0; i < this._sls.length; i += 1) {
        this._sls[i].style.transition = '';
        this._sls[i].style.transform = 'translateX(' + 100 * this._curPos[i] + '%)';
      }

      await asyncTimeout(10).set(); // Wait

      let d = 0;
      if (dir === 1) d = idx - this._curIdx;
      if (dir === -1) d = this._curIdx - idx;
      if (d < 0) d += this._size;

      for (let i = 0; i < d; i += 1) {
        const tf = d === 1 ? 'ease' : i === 0 ? 'ease-in' : i === d - 1 ? 'ease-out' : 'linear';
        this._curPos = this.shift(this._curPos, dir, this._time / d, tf);
        await asyncTimeout(Math.floor(this._time * 1000 / d)).set();
      }

      this._curIdx = idx;
    }

    shift(curPos, dir, time, tf = 'ease') {
      this._curIdxPsd += dir;
      if (this._sls.length - 1 < this._curIdxPsd) this._curIdxPsd = 0;
      if (this._curIdxPsd < 0) this._curIdxPsd = this._sls.length - 1;

      const pos = this._calcPosition(this._curIdxPsd, dir);

      for (let i = 0; i < this._sls.length; i += 1) {
        const t = Math.abs(curPos[i] - pos[i]) === 1 ? `transform ${time}s ${tf}` : '';
        this._sls[i].style.transition = t;
        this._sls[i].style.transform = `translateX(${100 * pos[i]}%)`;
      }

      return pos;
    }

    _calcPosition(idxPsd, dir) {
      const sizePsd = this._sls.length;
      const pos = new Array(sizePsd);
      pos[idxPsd] = 0;
      const hs = dir !== -1 ? Math.ceil((sizePsd - 1) / 2) : Math.floor((sizePsd - 1) / 2);
      const rs = sizePsd - 1 - hs;

      for (let i = 1; i <= hs; i += 1) {
        let j = idxPsd + i;
        if (sizePsd - 1 < j) j -= sizePsd;
        pos[j] = i;
      }

      for (let i = 1; i <= rs; i += 1) {
        let j = idxPsd - i;
        if (j < 0) j += sizePsd;
        pos[j] = -i;
      }

      return pos;
    }

  }
  /**
   *
   * Fade Transition
   *
   * @author Takuto Yanagida
   * @version 2021-06-25
   *
   */


  class TransitionFade {
    constructor(size, slides, tranTime) {
      this._size = size;
      this._sls = slides;
      this._time = tranTime;

      for (let i = 0; i < this._size; i += 1) {
        this._sls[i].style.opacity = i === 0 ? 1 : 0;
      }

      setTimeout(() => {
        for (let i = 0; i < this._size; i += 1) {
          this._sls[i].style.transition = 'opacity ' + this._time + 's';
        }
      }, 10);
    }

    async transition(idx, dir) {
      for (let i = 0; i < this._size; i += 1) {
        this._sls[i].style.opacity = i === idx ? 1 : 0;
        this._sls[i].style.pointerEvents = i === idx ? 'auto' : 'none';
      }

      await asyncTimeout(this._time * 1000).set();
    }

  }
  /**
   *
   * Image Picture
   *
   * @author Takuto Yanagida
   * @version 2021-06-28
   *
   */


  const CLS_PIC = NS + '-picture';
  const CLS_DUAL = 'dual';
  const CLS_SCROLL = 'scroll';
  const RANDOM_RATE = 10;

  class PictureImage {
    constructor(sl) {
      const p = document.createElement('div');
      p.classList.add(CLS_PIC);
      if (sl.classList.contains(CLS_SCROLL)) p.classList.add(CLS_SCROLL);
      const imgs = sl.querySelectorAll(':scope > img');

      if (imgs.length) {
        p.appendChild(imgs[0]);

        if (1 < imgs.length) {
          p.classList.add(CLS_DUAL);
          p.appendChild(imgs[1]);
        }
      } else if (sl.dataset.img) {
        p.appendChild(this._createImage(sl.dataset.img, sl.dataset.imgSrcset ?? null));

        if (sl.dataset.imgSub) {
          p.classList.add(CLS_DUAL);
          p.appendChild(this._createImage(sl.dataset.imgSub, sl.dataset.imgSubSrcset ?? null));
        }
      }

      this.p = p;
    }

    _createImage(src, srcset) {
      const img = document.createElement('img');
      img.src = src;
      if (srcset) img.srcset = srcset;
      return img;
    }

    getElement() {
      return this.p;
    }

    transition(isCur, size) {}

    display(isCur) {
      if (isCur) {
        this.p.classList.add(CLS_DISPLAY);
      } else {
        this.p.classList.remove(CLS_DISPLAY);
      }
    }

    getDuration(timeDur, timeTran, doRandom) {
      if (!doRandom) return timeDur;
      return dt * (1 + 0.01 * RANDOM_RATE * (1 - Math.random() * 2));
    }

  }
  /**
   *
   * Image Video
   *
   * @author Takuto Yanagida
   * @version 2021-06-29
   *
   */


  const CLS_VIDEO = NS + '-video';

  class PictureVideo {
    constructor(sl) {
      const p = document.createElement('div');
      p.classList.add(CLS_VIDEO);
      const vs = sl.querySelectorAll(':scope > video');

      if (1 === vs.length) {
        const v = vs[0];

        this._initializeVideo(v);

        this.v = p.appendChild(v);
      } else if (sl.dataset.video) {
        const v = document.createElement('video');

        this._initializeVideo(v);

        this.v = p.appendChild(v);
        const s = document.createElement('source');
        s.setAttribute('src', sl.dataset.video);
        v.appendChild(s);
      }

      this.p = p;
    }

    _initializeVideo(v) {
      v.muted = true;
      v.playsinline = true;
      v.setAttribute('muted', true);
      v.setAttribute('playsinline', true);
      v.addEventListener('loadedmetadata', () => {
        const ar = v.clientWidth / v.clientHeight;
        this.ar = (0 | ar * 1000) / 1000;
      });
    }

    getElement() {
      return this.p;
    }

    transition(isCur, size) {
      if (isCur) {
        this.v.setAttribute('autoplay', true);
        this.v.play();
        if (size === 1) this.v.setAttribute('loop', true);
      }
    }

    display(isCur) {
      if (!isCur) {
        this.v.pause();
        this.v.currentTime = 0;
      }
    }

    getDuration(timeDur, timeTran, doRandom) {
      return this.v.duration - timeTran;
    }

    onResize() {
      if (!this.ar) return false;
      const arFrame = this.p.clientWidth / this.p.clientHeight;

      if (this.ar < arFrame) {
        this.v.classList.remove('height');
        this.v.classList.add('width');
      } else {
        this.v.classList.remove('width');
        this.v.classList.add('height');
      }

      return true;
    }

  } // -------------------------------------------------------------------------


  initImages();
  document.addEventListener('DOMContentLoaded', () => {
    const io = new IntersectionObserver(es => {
      for (const e of es) root.classList[e.isIntersecting ? 'add' : 'remove'](CLS_VIEW);
    }, {
      rootMargin: `${OFFSET_VIEW}px 0px`
    });
    io.observe(root);
    transition(0, 0);
  });
  if (hasVideo) setTimeout(tryResizeVideo, 100);

  function tryResizeVideo() {
    const finish = onResizeVideo();
    if (!finish) setTimeout(tryResizeVideo, 100);
  } // -------------------------------------------------------------------------


  function initImages() {
    const scroll = root.classList.contains(CLS_SCROLL);

    for (const sl of slides) {
      if (scroll) sl.classList.add(CLS_SCROLL);
      sl.style.opacity = 0; // for avoiding flickering slides on page loading

      let p = null;

      if (isVideo(sl)) {
        p = new PictureVideo(sl);
        hasVideo = true;
      } else {
        p = new PictureImage(sl);
      }

      sl.insertBefore(p.getElement(), sl.firstChild);
      pics.push(p);
    }

    if (hasVideo) onResize(onResizeVideo);

    switch (effectType) {
      case 'slide':
        effect = new TransitionSlide(size, slides, timeTran);
        break;

      case 'scroll':
        effect = new TransitionScroll(size, slides, timeTran);
        break;

      case 'fade':
        effect = new TransitionFade(size, slides, timeTran);
        break;

      default:
        effect = new TransitionSlide(size, slides, timeTran);
        break;
    }
  }

  function isVideo(sl) {
    if (sl.dataset.video) return true;
    const vs = sl.querySelectorAll(':scope > video');
    return 0 < vs.length;
  }

  function onResizeVideo() {
    let finish = true;

    for (let i = 0; i < size; i += 1) {
      const p = pics[i];

      if (p instanceof PictureVideo) {
        if (!p.onResize()) finish = false;
      }
    }

    return finish;
  } // -------------------------------------------------------------------------


  let curIdx = 0;
  let stStep = null;
  let last = 0;

  async function transition(idx, dir) {
    [idx, dir] = getIdxDir(idx, dir);
    const t = window.performance.now();
    if (dir !== 0 && t - last < timeTran * 1000) return;
    last = t;

    for (let i = 0; i < slides.length; i += 1) {
      pics[i].transition(i % size === idx, size);
    }

    await effect.transition(idx, dir);
    if (onTransitionEnd) onTransitionEnd();
    curIdx = idx;
    display(idx);
  }

  async function display(idx) {
    for (let i = 0; i < slides.length; i += 1) {
      pics[i].display(i % size === idx);
    }

    if (size === 1) return;
    const dt = pics[idx].getDuration(timeDur, timeTran, randomTiming);
    if (stStep) stStep.clear();
    stStep = asyncTimeout(Math.ceil(dt * 1000), step);
    await stStep.set();
  }

  async function step() {
    if (root.classList.contains(CLS_VIEW) && !root.classList.contains(CLS_PAUSE)) {
      transition(null, 1);
    } else {
      asyncTimeout(timeDur * 1000, step).set();
    }
  }

  function getIdxDir(idx, dir) {
    if (idx === null) {
      idx = curIdx + dir;
      if (size - 1 < idx) idx = 0;
      if (idx < 0) idx = size - 1;
    } else if (dir === 0) {
      if (curIdx < idx) {
        dir = 1;
        if (curIdx - (idx - size) < idx - curIdx) dir = -1;
      }

      if (idx < curIdx) {
        dir = -1;
        if (idx + size - curIdx < curIdx - idx) dir = 1;
      }
    }

    return [idx, dir];
  } // -------------------------------------------------------------------------


  return {
    next: () => {
      transition(curIdx === size - 1 ? 0 : curIdx + 1, 1);
    },
    previous: () => {
      transition(curIdx === 0 ? size - 1 : curIdx - 1, -1);
    },
    onTransitionEnd: fn => {
      onTransitionEnd = fn;
    }
  };
};
//# sourceMappingURL=hero.min.js.map
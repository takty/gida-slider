"use strict";

/**
 *
 * Gida Slider - Show (JS)
 *
 * @author Takuto Yanagida
 * @version 2021-07-05
 *
 */
window.GIDA = window['GIDA'] ?? {};

window.GIDA.slider_show = function (id, opts) {
  const NS = 'gida-slider-show';
  const CLS_FRAME = NS + '-frame';
  const CLS_SLIDES = NS + '-slides';
  const CLS_VISIBLE = 'visible';
  const CLS_DISPLAY = 'display';
  const CLS_VIEW = 'view';
  const CLS_PAUSE = 'pause';
  const OFFSET_VIEW = 100;
  const root = id ? document.getElementById(id) : document.getElementsByClassName(NS)[0];
  if (!root) return;
  if (opts === undefined) opts = {};
  const effectType = opts['effect_type'] ?? 'slide';
  const timeDur = opts['duration_time'] ?? 8; // [second]

  const timeTran = opts['transition_time'] ?? 1; // [second]

  const randomTiming = opts['is_random_timing'] ?? false;
  let bgVisible = opts['is_background_visible'] ?? true;
  let sideVisible = opts['is_side_slide_visible'] ?? false;
  if (effectType !== 'scroll') sideVisible = false;

  if (sideVisible) {
    bgVisible = false;
    const ss = root.querySelector('.' + CLS_SLIDES);
    ss.style.overflow = 'visible';
  }

  const slides = Array.prototype.slice.call(root.querySelectorAll(`.${CLS_SLIDES} > li`));
  const size = slides.length;
  const pics = [];
  let effect = null;
  let onTransitionEnd = null;
  let hasVideo = false; // -------------------------------------------------------------------------

  /**
   *
   * Common Functions (JS)
   *
   * @author Takuto Yanagida
   * @version 2021-06-30
   *
   */

  const resizeListeners = [];

  function onResize(fn, doFirst = false) {
    if (doFirst) fn();
    resizeListeners.push(throttle(fn));
  } // -----------------------------------------------------------------------------


  document.addEventListener('DOMContentLoaded', () => {
    window.addEventListener('resize', () => {
      for (const l of resizeListeners) l();
    }, {
      passive: true
    });
  });

  function throttle(fn) {
    let isRunning;

    function run() {
      isRunning = false;
      fn();
    }

    return () => {
      if (isRunning) return;
      isRunning = true;
      requestAnimationFrame(run);
    };
  }

  function asyncTimeout(ms, fn = () => {}) {
    let tid = null;
    let res;
    return {
      set: () => new Promise(r => {
        res = r;
        tid = setTimeout(async () => {
          tid = null;
          await fn();
          r();
        }, ms);
      }),
      clear: () => {
        if (tid) {
          clearTimeout(tid);
          tid = null;
          res();
        }
      }
    };
  }
  /**
   *
   * Backgrounds
   *
   * @author Takuto Yanagida
   * @version 2021-06-24
   *
   */


  const CLS_BGS = NS + '-backgrounds';
  const bgs = [];

  function initBackgrounds(size, root, slides, time) {
    const frame = document.createElement('div');
    frame.classList.add(CLS_BGS);
    root.insertBefore(frame, root.firstChild);

    for (let i = 0; i < size; i += 1) {
      const sl = slides[i];
      const bg = document.createElement('div');
      const img = sl.dataset.img ?? sl.dataset.imgLeft;

      if (img) {
        bg.style.backgroundImage = `url('${img}')`;
        bg.style.transitionDuration = `${time * 2}s`;
      }

      frame.appendChild(bg);
      bgs.push(bg);
    }
  }

  function transitionBackgrounds(idx, size) {
    for (let i = 0; i < size; i += 1) {
      if (!bgs[i]) continue;
      bgs[i].classList[i === idx ? 'add' : 'remove'](CLS_VISIBLE);
    }
  }
  /**
   *
   * Buttons
   *
   * @author Takuto Yanagida
   * @version 2021-06-25
   *
   */


  const CLS_PREV = NS + '-prev';
  const CLS_NEXT = NS + '-next';

  function initButtons(size, root, transitionFn) {
    const prevBtn = root.getElementsByClassName(CLS_PREV)[0];
    const nextBtn = root.getElementsByClassName(CLS_NEXT)[0];

    if (size === 1) {
      if (prevBtn) prevBtn.style.display = 'none';
      if (nextBtn) nextBtn.style.display = 'none';
      return;
    }

    const prevFn = async () => {
      await transitionFn(null, -1);
    };

    const nextFn = async () => {
      await transitionFn(null, 1);
    };

    if (prevBtn) prevBtn.addEventListener('click', async () => {
      prevBtn.disabled = true;
      await prevFn();
      prevBtn.disabled = false;
    });
    if (nextBtn) nextBtn.addEventListener('click', async () => {
      nextBtn.disabled = true;
      await nextFn();
      nextBtn.disabled = false;
    });
    if (window.ontouchstart === null) _initFlick(root, prevFn, nextFn);
  }

  function _initFlick(root, prevFn, nextFn) {
    const DX = 50;
    let stX, mvX, mvY;
    const frame = root.getElementsByClassName(CLS_FRAME)[0];
    frame.addEventListener('touchstart', e => {
      stX = e.touches[0].pageX;
      mvX = mvY = null;
    });
    frame.addEventListener('touchmove', e => {
      mvX = e.changedTouches[0].pageX;
      mvY = e.changedTouches[0].pageY;
    });
    frame.addEventListener('touchend', e => {
      if (mvX === null || mvY === null) return;

      if (mvX < stX - DX) {
        // <-
        nextFn();
        if (e.cancelable === true) e.preventDefault();
      } else if (stX + DX < mvX) {
        // ->
        prevFn();
        if (e.cancelable === true) e.preventDefault();
      }
    });
  }
  /**
   *
   * Rivets
   *
   * @author Takuto Yanagida
   * @version 2021-06-24
   *
   */


  const CLS_RIVETS = NS + '-rivets';
  const CLS_RIVET = NS + '-rivet';
  const rivets = [];

  function initRivets(size, root, transitionFn) {
    if (size === 1) return;
    const rs = root.getElementsByClassName(CLS_RIVETS)[0];
    if (!rs) return;
    const dir = size === 2 ? 1 : 0;

    for (let i = 0; i < size; i += 1) {
      const idx = i;
      const r = document.createElement('span');
      r.id = id + '-rivet-' + idx;
      r.className = CLS_RIVET;
      r.addEventListener('click', () => {
        transitionFn(idx, dir);
      });
      rs.appendChild(r);
      rivets.push(r);
    }
  }

  function transitionRivets(idx) {
    for (const r of rivets) r.classList.remove(CLS_VISIBLE);

    if (rivets[idx]) rivets[idx].classList.add(CLS_VISIBLE);
  }
  /**
   *
   * Thumbnails
   *
   * @author Takuto Yanagida
   * @version 2021-06-24
   *
   */


  const thumbs = [];

  function initThumbnails(size) {
    if (size === 1) return;

    for (let i = 0; i < size; i += 1) {
      const tid = id + '-' + i;
      let it = document.querySelector('*[data-id="' + tid + '"]');
      if (!it) it = document.getElementById(tid);
      thumbs.push(it);
    }
  }

  function transitionThumbnails(idx) {
    for (const t of thumbs) {
      if (t) t.classList.remove(CLS_VISIBLE);
    }

    if (thumbs[idx]) thumbs[idx].classList.add(CLS_VISIBLE);
  }
  /**
   *
   * Indicators
   *
   * @author Takuto Yanagida
   * @version 2021-06-23
   *
   */


  const CLS_SLIDE_CNT = NS + '-slide-count';
  const CLS_SLIDE_IDX = NS + '-slide-index';
  let slideCntElms = [];
  let slideIdxElms = [];

  function initIndicators(size, root) {
    slideCntElms = root.querySelectorAll('.' + CLS_SLIDE_CNT);
    slideIdxElms = root.querySelectorAll('.' + CLS_SLIDE_IDX);

    for (const elm of slideCntElms) elm.innerHTML = size;

    for (const elm of slideIdxElms) elm.innerHTML = 1;
  }

  function transitionIndicators(idx) {
    for (const elm of slideIdxElms) elm.innerHTML = idx + 1;
  }
  /**
   *
   * Captions
   *
   * @author Takuto Yanagida
   * @version 2021-06-28
   *
   */


  const CLS_CAP = NS + '-caption';
  const caps = [];

  function createCaption(sl, time) {
    const c = sl.querySelector(':scope > div');

    if (c) {
      c.style.transitionDuration = time + 's';

      if (c.className === '') {
        c.classList.add(CLS_CAP);
        c.classList.add('subtitle');
      }

      if (!c.classList.contains('line') && !c.classList.contains('circle')) c.classList.add('subtitle');
      if (c.classList.contains('line')) c.dataset.caption = 'line';
      if (c.classList.contains('circle')) c.dataset.caption = 'circle';
      if (c.classList.contains('subtitle')) c.dataset.caption = 'subtitle';
      const ds = c.querySelectorAll(':scope > div');

      for (const d of ds) _wrapText(d);

      _wrapText(c);

      const ss = c.querySelectorAll(':scope > span');

      if (0 < ss.length) {
        const div = document.createElement('div');

        for (const s of ss) div.appendChild(c.removeChild(s));

        c.appendChild(div);
      }
    }

    caps.push(c);
  }

  function _wrapText(c) {
    for (let i = 0; i < c.childNodes.length; i += 1) {
      const cs = c.childNodes[i];

      if (cs.nodeType === 3
      /*TEXT_NODE*/
      ) {
          if (cs.nodeValue.trim() === '') continue;
          const span = document.createElement('span');
          span.appendChild(document.createTextNode(cs.nodeValue));
          cs.parentNode.replaceChild(span, cs);
        }
    }
  }

  function onResizeCaption() {
    if (window.innerWidth < 600) {
      for (const c of caps) {
        if (!c) continue;
        c.classList.remove(c.dataset.caption);
        c.classList.add('subtitle');
      }
    } else {
      for (const c of caps) {
        if (!c) continue;
        c.classList.remove('subtitle');
        c.classList.add(c.dataset.caption);
      }
    }
  }

  function displayCaption(idx, size) {
    for (let i = 0; i < caps.length; i += 1) {
      if (!caps[i]) continue;
      if (i % size === idx) caps[i].classList.add(CLS_DISPLAY);else caps[i].classList.remove(CLS_DISPLAY);
    }
  }
  /**
   *
   * Slide Transition
   *
   * @author Takuto Yanagida
   * @version 2021-06-25
   *
   */


  class TransitionSlide {
    constructor(size, slides, tranTime) {
      this._size = size;
      this._sls = slides;
      this._time = tranTime;

      for (let i = 0; i < this._size; i += 1) {
        this._sls[i].style.transform = 'translateX(' + (i ? 100 : 0) + '%)';
      }

      setTimeout(() => {
        for (let i = 0; i < this._size; i += 1) {
          this._sls[i].style.opacity = 1;
          this._sls[i].style.transition = 'transform ' + this._time + 's';
        }
      }, 10);
    }

    async transition(idx, dir) {
      for (let i = 0; i < this._size; i += 1) {
        this._sls[i].style.transform = i <= idx ? 'translateX(0%)' : 'translateX(100%)';
      }

      await asyncTimeout(this._time * 1000).set();
    }

  }
  /**
   *
   * Scroll Transition
   *
   * @author Takuto Yanagida
   * @version 2021-06-29
   *
   */


  class TransitionScroll {
    constructor(size, slides, tranTime) {
      this._size = size;
      this._sls = slides;
      this._time = tranTime;
      this._curIdx = 0;
      this._curIdxPsd = 0;
      this._curPos = this._calcPosition(0, 1);

      for (let i = 0; i < this._sls.length; i += 1) {
        this._sls[i].style.opacity = 1;
        this._sls[i].style.transform = `translateX(${this._curPos[i] * 100}%)`;
      }
    }

    async transition(idx, dir) {
      this._curPos = this._calcPosition(this._curIdxPsd, dir);

      for (let i = 0; i < this._sls.length; i += 1) {
        this._sls[i].style.transition = '';
        this._sls[i].style.transform = 'translateX(' + 100 * this._curPos[i] + '%)';
      }

      await asyncTimeout(10).set(); // Wait

      let d = 0;
      if (dir === 1) d = idx - this._curIdx;
      if (dir === -1) d = this._curIdx - idx;
      if (d < 0) d += this._size;

      for (let i = 0; i < d; i += 1) {
        const tf = d === 1 ? 'ease' : i === 0 ? 'ease-in' : i === d - 1 ? 'ease-out' : 'linear';
        this._curPos = this.shift(this._curPos, dir, this._time / d, tf);
        await asyncTimeout(Math.floor(this._time * 1000 / d)).set();
      }

      this._curIdx = idx;
    }

    shift(curPos, dir, time, tf = 'ease') {
      this._curIdxPsd += dir;
      if (this._sls.length - 1 < this._curIdxPsd) this._curIdxPsd = 0;
      if (this._curIdxPsd < 0) this._curIdxPsd = this._sls.length - 1;

      const pos = this._calcPosition(this._curIdxPsd, dir);

      for (let i = 0; i < this._sls.length; i += 1) {
        const t = Math.abs(curPos[i] - pos[i]) === 1 ? `transform ${time}s ${tf}` : '';
        this._sls[i].style.transition = t;
        this._sls[i].style.transform = `translateX(${100 * pos[i]}%)`;
      }

      return pos;
    }

    _calcPosition(idxPsd, dir) {
      const sizePsd = this._sls.length;
      const pos = new Array(sizePsd);
      pos[idxPsd] = 0;
      const hs = dir !== -1 ? Math.ceil((sizePsd - 1) / 2) : Math.floor((sizePsd - 1) / 2);
      const rs = sizePsd - 1 - hs;

      for (let i = 1; i <= hs; i += 1) {
        let j = idxPsd + i;
        if (sizePsd - 1 < j) j -= sizePsd;
        pos[j] = i;
      }

      for (let i = 1; i <= rs; i += 1) {
        let j = idxPsd - i;
        if (j < 0) j += sizePsd;
        pos[j] = -i;
      }

      return pos;
    }

  }
  /**
   *
   * Fade Transition
   *
   * @author Takuto Yanagida
   * @version 2021-06-25
   *
   */


  class TransitionFade {
    constructor(size, slides, tranTime) {
      this._size = size;
      this._sls = slides;
      this._time = tranTime;

      for (let i = 0; i < this._size; i += 1) {
        this._sls[i].style.opacity = i === 0 ? 1 : 0;
      }

      setTimeout(() => {
        for (let i = 0; i < this._size; i += 1) {
          this._sls[i].style.transition = 'opacity ' + this._time + 's';
        }
      }, 10);
    }

    async transition(idx, dir) {
      for (let i = 0; i < this._size; i += 1) {
        this._sls[i].style.opacity = i === idx ? 1 : 0;
        this._sls[i].style.pointerEvents = i === idx ? 'auto' : 'none';
      }

      await asyncTimeout(this._time * 1000).set();
    }

  }
  /**
   *
   * Image Picture
   *
   * @author Takuto Yanagida
   * @version 2021-06-28
   *
   */


  const CLS_PIC = NS + '-picture';
  const CLS_DUAL = 'dual';
  const CLS_SCROLL = 'scroll';
  const RANDOM_RATE = 10;

  class PictureImage {
    constructor(sl) {
      const p = document.createElement('div');
      p.classList.add(CLS_PIC);
      if (sl.classList.contains(CLS_SCROLL)) p.classList.add(CLS_SCROLL);
      const imgs = sl.querySelectorAll(':scope > img');

      if (imgs.length) {
        p.appendChild(imgs[0]);

        if (1 < imgs.length) {
          p.classList.add(CLS_DUAL);
          p.appendChild(imgs[1]);
        }
      } else if (sl.dataset.img) {
        p.appendChild(this._createImage(sl.dataset.img, sl.dataset.imgSrcset ?? null));

        if (sl.dataset.imgSub) {
          p.classList.add(CLS_DUAL);
          p.appendChild(this._createImage(sl.dataset.imgSub, sl.dataset.imgSubSrcset ?? null));
        }
      }

      this.p = p;
    }

    _createImage(src, srcset) {
      const img = document.createElement('img');
      img.src = src;
      if (srcset) img.srcset = srcset;
      return img;
    }

    getElement() {
      return this.p;
    }

    transition(isCur, size) {}

    display(isCur) {
      if (isCur) {
        this.p.classList.add(CLS_DISPLAY);
      } else {
        this.p.classList.remove(CLS_DISPLAY);
      }
    }

    getDuration(timeDur, timeTran, doRandom) {
      if (!doRandom) return timeDur;
      return dt * (1 + 0.01 * RANDOM_RATE * (1 - Math.random() * 2));
    }

  }
  /**
   *
   * Image Video
   *
   * @author Takuto Yanagida
   * @version 2021-06-29
   *
   */


  const CLS_VIDEO = NS + '-video';

  class PictureVideo {
    constructor(sl) {
      const p = document.createElement('div');
      p.classList.add(CLS_VIDEO);
      const vs = sl.querySelectorAll(':scope > video');

      if (1 === vs.length) {
        const v = vs[0];

        this._initializeVideo(v);

        this.v = p.appendChild(v);
      } else if (sl.dataset.video) {
        const v = document.createElement('video');

        this._initializeVideo(v);

        this.v = p.appendChild(v);
        const s = document.createElement('source');
        s.setAttribute('src', sl.dataset.video);
        v.appendChild(s);
      }

      this.p = p;
    }

    _initializeVideo(v) {
      v.muted = true;
      v.playsinline = true;
      v.setAttribute('muted', true);
      v.setAttribute('playsinline', true);
      v.addEventListener('loadedmetadata', () => {
        const ar = v.clientWidth / v.clientHeight;
        this.ar = (0 | ar * 1000) / 1000;
      });
    }

    getElement() {
      return this.p;
    }

    transition(isCur, size) {
      if (isCur) {
        this.v.setAttribute('autoplay', true);
        this.v.play();
        if (size === 1) this.v.setAttribute('loop', true);
      }
    }

    display(isCur) {
      if (!isCur) {
        this.v.pause();
        this.v.currentTime = 0;
      }
    }

    getDuration(timeDur, timeTran, doRandom) {
      return this.v.duration - timeTran;
    }

    onResize() {
      if (!this.ar) return false;
      const arFrame = this.p.clientWidth / this.p.clientHeight;

      if (this.ar < arFrame) {
        this.v.classList.remove('height');
        this.v.classList.add('width');
      } else {
        this.v.classList.remove('width');
        this.v.classList.add('height');
      }

      return true;
    }

  } // -------------------------------------------------------------------------


  initImages();
  if (bgVisible) initBackgrounds(size, root, slides, timeTran);
  document.addEventListener('DOMContentLoaded', () => {
    initButtons(size, root, transition);
    initThumbnails(size);
    initIndicators(size, root);
    initRivets(size, root, transition);
    const io = new IntersectionObserver(es => {
      for (const e of es) root.classList[e.isIntersecting ? 'add' : 'remove'](CLS_VIEW);
    }, {
      rootMargin: `${OFFSET_VIEW}px 0px`
    });
    io.observe(root);
    transition(0, 0);
  });
  if (hasVideo) setTimeout(tryResizeVideo, 100);

  function tryResizeVideo() {
    const finish = onResizeVideo();
    if (!finish) setTimeout(tryResizeVideo, 100);
  } // -------------------------------------------------------------------------


  function initImages() {
    if (effectType === 'scroll' && 1 < size && size < 5) {
      cloneSlides();
    }

    const scroll = root.classList.contains(CLS_SCROLL);

    for (const sl of slides) {
      if (scroll) sl.classList.add(CLS_SCROLL);
      sl.style.opacity = 0; // for avoiding flickering slides on page loading

      createCaption(sl, timeTran);
      let p = null;

      if (isVideo(sl)) {
        p = new PictureVideo(sl);
        hasVideo = true;
      } else {
        p = new PictureImage(sl);
      }

      sl.insertBefore(p.getElement(), sl.firstChild);
      const e = sl.querySelector('a') ?? sl;
      e.insertBefore(p.getElement(), e.firstChild);
      pics.push(p);
    }

    if (hasVideo) onResize(onResizeVideo);
    onResize(onResizeCaption, true);

    switch (effectType) {
      case 'slide':
        effect = new TransitionSlide(size, slides, timeTran);
        break;

      case 'scroll':
        effect = new TransitionScroll(size, slides, timeTran);
        break;

      case 'fade':
        effect = new TransitionFade(size, slides, timeTran);
        break;

      default:
        effect = new TransitionSlide(size, slides, timeTran);
        break;
    }
  }

  function isVideo(sl) {
    if (sl.dataset.video) return true;
    const vs = sl.querySelectorAll(':scope > video');
    return 0 < vs.length;
  }

  function onResizeVideo() {
    let finish = true;

    for (let i = 0; i < size; i += 1) {
      const p = pics[i];

      if (p instanceof PictureVideo) {
        if (!p.onResize()) finish = false;
      }
    }

    return finish;
  }

  function cloneSlides() {
    for (let i = 0; i < size; i += 1) {
      const sl = slides[i];
      const nsl = sl.cloneNode(true);
      slides.push(nsl);
      sl.parentNode.appendChild(nsl);
    }
  } // -------------------------------------------------------------------------


  let curIdx = 0;
  let stStep = null;
  let last = 0;

  async function transition(idx, dir) {
    [idx, dir] = getIdxDir(idx, dir);
    const t = window.performance.now();
    if (dir !== 0 && t - last < timeTran * 1000) return;
    last = t;

    for (let i = 0; i < slides.length; i += 1) {
      pics[i].transition(i % size === idx, size);
    }

    transitionBackgrounds(idx, size);
    transitionThumbnails(idx);
    transitionIndicators(idx);
    transitionRivets(idx);
    await effect.transition(idx, dir);
    if (onTransitionEnd) onTransitionEnd();
    curIdx = idx;
    display(idx);
  }

  async function display(idx) {
    for (let i = 0; i < slides.length; i += 1) {
      pics[i].display(i % size === idx);
    }

    displayCaption(idx, size);
    if (size === 1) return;
    const dt = pics[idx].getDuration(timeDur, timeTran, randomTiming);
    if (stStep) stStep.clear();
    stStep = asyncTimeout(Math.ceil(dt * 1000), step);
    await stStep.set();
  }

  async function step() {
    if (root.classList.contains(CLS_VIEW) && !root.classList.contains(CLS_PAUSE)) {
      transition(null, 1);
    } else {
      asyncTimeout(timeDur * 1000, step).set();
    }
  }

  function getIdxDir(idx, dir) {
    if (idx === null) {
      idx = curIdx + dir;
      if (size - 1 < idx) idx = 0;
      if (idx < 0) idx = size - 1;
    } else if (dir === 0) {
      if (curIdx < idx) {
        dir = 1;
        if (curIdx - (idx - size) < idx - curIdx) dir = -1;
      }

      if (idx < curIdx) {
        dir = -1;
        if (idx + size - curIdx < curIdx - idx) dir = 1;
      }
    }

    return [idx, dir];
  } // -------------------------------------------------------------------------


  return {
    next: () => {
      transition(curIdx === size - 1 ? 0 : curIdx + 1, 1);
    },
    previous: () => {
      transition(curIdx === 0 ? size - 1 : curIdx - 1, -1);
    },
    onTransitionEnd: fn => {
      onTransitionEnd = fn;
    }
  };
};

window.GIDA.slider_show_page = function (id, idx) {
  const btn = document.getElementById(id + '-rivet-' + idx);
  if (btn) btn.click();
};
//# sourceMappingURL=show.min.js.map